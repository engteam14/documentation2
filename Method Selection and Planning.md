## Part A


### Software Engineering Methods


Our chosen Software Engineering method was Agile, where we used the Scrum framework. The team was divided into two smaller teams, namely, Implementation and Documentation Team. We then came up with a project “road-map” early in the development process as illustrated in Fig.1. As we deicded to the Scrum framework, our road-map shows a sprint of 2-weeks for each task followed by a review stage where we would discuss our progress and work on solutions to any problems the team is having. Once we had an idea of the main blocks of work that needed to be done, the team discussed all the smaller tasks that needed to be completed in order to complete a main block of work and we then used GitHub Issues where each member from the two teams were assigned tasks that need to be done. Having all the requirements for the final game from the customer, our roadmap helped us efficiently plan the execution and completion of this project, with the aim of delivering a high-quality game and all its supporting documents on time.  

We organised frequent team meetings, on average twice a week. These meetings served two key purposes:



* Providing a platform to discuss and agree upon key development decisions, such as game design and documentation. 
* Allowing each  team member to communicate their progress on their assigned tasks, and for new tasks to be assigned when necessary.

As discussed earlier, we broke down the tasks into sub-tasks according to the marks and assigned each member ~15 marks worth of tasks based on their skillset and our experience from the first assessment, so that every member had an equal amount of contribution towards the project. The frequent team meetings alongside the bi-weekly review meetings, in which we discussed task progression, allowed us to keep each other accountable for our productivity and ensured that we stay on track.


### Tools Used

**Communication and Collaboration**



* For our team meetings we either organised a discord call or met in-person. Using discord was an intuitive choice as it is a platform that we all have lots of experience with and therefore avoided an unnecessary learning curve.
* We created a Discord server for general communications throughout the project. This was crucial in allowing team members to ask clarifying questions without having to wait for the next meeting, avoiding any unnecessary obstructions to task progression. Moreover, we created a "To-do list" channel in our server where after every meeting notes were posted regarding what was discussed in the meeting and what needed to be done.
* We used GitHub Issues in order to organise and keep track of our tasks throughout the project. Alongside the team meetings, this was crucial in keeping us organised by providing a numerical representation of tasks that were completed (closed issues) and tasks that were in progress or yet to begin (open issues).

**Website**



* We used GitHub pages to develop our website considering the teams previous experience with using the tool. 

**Architecture**



* We used PlantUML in order to create the abstract and concrete architecture diagrams as the team had prior experience in using this tool.

**Implementation**



* We chose to use IntelliJ as our IDE. This was due to both the ease of use offered by the tool, along with the fact that several team members had previous experience with the tool: it felt like the ideal choice to avoid unnecessary and time-consuming learning curves.
* We utilised the libGDX game development framework during the implementation of our game. Similarly, to our choice of IDE, this was largely influenced by the previous experience of the team. We were also aware that LibGDX was a popular choice amongst other teams and therefore our use of this framework may make it easier for another team to take over and expand our code.


### Alternatives considered



* We considered using other IDEs such as Eclipse for software implementation, however as mentioned previously we chose to use IntelliJ due to team members having previous experience with this IDE.
* We also considered game engines other than libGDX in order to enable software development:
    * We considered using Unity, however we were discouraged from this choice by factors such as Unity’s reputation for largely outdated/incomplete documentation and the fact that many useful features are behind a paywall.
    * We also considered using the Unreal game engine, but quickly decided against this as it seemed inappropriate for developing what is a relatively small game and would cause the resulting game to be unnecessarily bloated.




## Part B


### Team Roles

During our initial team meeting we discussed assigning the following team roles.



* Meeting Chair: Ensuring organised and efficient team meetings that covered all necessary updates and decisions
* Secretary: Recording team decisions and keeping notes of the content discussed in each team meeting
* Librarian: Keeping track of documents and other resources, particularly ensuring that in-progress documents were regularly uploaded to the team shared google drive
* Report Editor: Overseeing document production, in particular ensuring that documentation progress was largely in line with the initial working plan

During this discussion we decided to combine all the roles as they seemed like largely interdependent tasks, hence forming the main role of Team Leader. We then added two addition roles, Implementation leader and Documentation leader, and discussed who would be most appropriate for each role and agreed on the following assignments:
  * Team Leader – Katie
  * Implementation Leader – Jacob 
  * Documentation Leader – Saud


Assigning these roles enabled a smooth and efficient team working process and helped to keep track of team progress.


### Task Assignments

Task assignment took place once we had gathered all the requirements for the game as mentioned above. We went through all the deliverables required in Assessment 2 and discussed each major task that had to be done. We then calculated how much each task was worth and assigned each member ~15 marks worth of tasks using GitHub Issues based on their skill set and the groups experience from Assessment 1, in order to ensure efficiency and timely completion of tasks. We also made sure that each member’s work was reviewed by at least one other team member so that appropriate feedback could be given before the approval of a merge request and the member working on it could make any necessary changes. We then added sub-tasks to these major tasks and such sub-tasks were added till our last review session in order to ensure that each part of the deliverable was completed, and nothing was forgotten.




## Part C


### Intro

Our first step in planning this assessment was to create a "road-map" for the entire project in the form of a Gantt Chart, as shown below. 

![Fig.1](https://user-images.githubusercontent.com/94641110/158235276-dc7d414d-a650-4fc6-addb-92a8a9f74013.png)

This road-map was made by referring to both, the Product Brief and the Team Assessment documents, highlighting all the main tasks which had to be completed in order to successfully complete and submit this project on time. Although the submission deadline was the 4th of May, we decided to set an early deadline for ourselves so that we could maximize efficiency and will have a few "buffer" days if in case things go wrong (e.g., a member falling ill and unable to do their assigned tasks so someone else taking over).

Once we had a Project Plan, we then assigned tasks to individuals/teams, using a colour-coding scheme, as shown below. The members for each of our two previously mentioned teams are as follows:
* Implementation Team: Jacob, Katie, Cody
* Documentation Team: Saud, Felix, Joachim

![Team Tasks1](https://user-images.githubusercontent.com/94641110/158831684-f1b32b90-12be-4f6e-80c1-8996012dc00e.png)

The colour-coding scheme is as follows:
* Grey = everyone
* Implementation team = GreenYellow
* Documentation team = Yellow
* Saud = DarkBlue
* Katie = Purple
* Jacob = Green


At each team meeting our Group Leader, Katie, would create meeting notes which she would then upload to our discord server. Based on these notes, we would work on our assigned tasks/new tasks until the next meeting/review session where we would compare our progress with the road-map to see where we stand in terms of the submission deadline and the work to-be-done. 

